<!DOCTYPE html>
<html lang="en">

<head>
    <script src="/socket.io/socket.io.js"></script>
    <script src="./cookie.js"></script>
    <link rel="stylesheet" href="index.css">
    <title>Game</title>
</head>

<body>
    <canvas id="worldLayer" width="1000px" height="1000px"
        style="position: absolute; z-index: 1; border-style: solid; border-color: cadetblue;"></canvas>
    <canvas id="playerLayer" width="1000px" height="1000px" style="position: absolute; z-index: 2;"></canvas>
    <h3 class="unselectable" style="position: absolute; bottom: 0;">WASD to move. Left click to shoot.</h3>
    <script>
        const socket = io();
        socket.on('connect', () => {
            socket.emit('set name', getCookie('name'));
        });

        const name = getCookie('name');
        const playerRadius = 6;
        const bulletRadius = 2;
        const pi2 = Math.PI * 2;
        const canvasHeight = 200;
        const canvasWidth = 400;

        const worldCanvas = document.getElementById('worldLayer');
        const playerCanvas = document.getElementById('playerLayer');

        worldCanvas.width = window.innerWidth;
        worldCanvas.height = window.innerHeight;

        const worldCtx = worldCanvas.getContext("2d");
        const playerCtx = playerCanvas.getContext("2d");

        let heightScale = 1;
        let widthScale = 1;
        const resizeCanvas = () => {
            heightScale = Math.floor(window.innerHeight / canvasHeight);
            widthScale = Math.floor(window.innerWidth / canvasWidth);

            let newHeight = heightScale * canvasHeight;
            let newWidth = widthScale * canvasWidth;

            if (newHeight * 2 !== newWidth) {
                if (newHeight > newWidth) {
                    newHeight = newWidth / 2;
                    heightScale = newHeight/canvasHeight;
                } else {
                    newWidth = newHeight * 2;
                    widthScale = newWidth/canvasWidth;
                }
            }

            worldCanvas.height = newHeight;
            worldCanvas.width = newWidth;
            playerCanvas.height = newHeight;
            playerCanvas.width = newWidth;

            worldCtx.scale(widthScale, heightScale);
            playerCtx.scale(widthScale, heightScale);

            playerCtx.clearRect(0, 0, canvasWidth, canvasHeight);

            playerCtx.beginPath();
            playerCtx.fillStyle = 'black';
            playerCtx.moveTo(canvasWidth / 2 + playerRadius, canvasHeight / 2);
            playerCtx.arc(canvasWidth / 2, canvasHeight / 2, playerRadius, 0, pi2);
            playerCtx.fillText(name, canvasWidth / 2 - 2 * playerRadius, canvasHeight / 2 - 2 * playerRadius);
            playerCtx.fillStyle = 'red';
            playerCtx.stroke();
            playerCtx.fill();
        }

        resizeCanvas()

        window.onresize = resizeCanvas;

        const middleTracker = { x: 0, y: 0 };
        let playerPos = { x: canvasWidth / 2, y: canvasHeight / 2 };

        const bg_x = [0, 200, 400, 600, 800, 1000];
        const updateBackground = () => {
            worldCtx.beginPath();
            worldCtx.fillStyle = 'rgba(211, 211, 211, 0.5)';
            for (let i = 0; i < bg_x.length; i++) {
                const h = bg_x[i];
                if (h > playerPos.y - canvasHeight / 2 || h < playerPos.y + canvasHeight / 2) {
                    if (h === 0 || h === 1000) {
                        worldCtx.fillStyle = 'black';
                        worldCtx.fillRect(0, h + middleTracker.y, canvasWidth, 1);
                        worldCtx.fillStyle = 'rgba(211, 211, 211, 0.5)';
                    } else {
                        worldCtx.fillRect(0, h + middleTracker.y, canvasWidth, 1);
                    }
                }
                if (h > playerPos.x - canvasWidth / 2 || h < playerPos.x + canvasWidth / 2) {
                    if (h === 0 || h === 1000) {
                        worldCtx.fillStyle = 'black';
                        worldCtx.fillRect(h + middleTracker.x, 0, 1, canvasHeight);
                        worldCtx.fillStyle = 'rgba(211, 211, 211, 0.5)';
                    } else {
                        worldCtx.fillRect(h + middleTracker.x, 0, 1, canvasHeight);
                    }
                }
            }

            requestAnimationFrame(updateBackground);
        };
        requestAnimationFrame(updateBackground);

        socket.on('update state', (states) => {
            const thisPosition = states.players[states.socketId];
            playerPos = thisPosition;
            middleTracker.x = -(thisPosition.x - canvasWidth / 2);
            middleTracker.y = -(thisPosition.y - canvasHeight / 2);
            worldCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            updatePlayer(states.players, states.socketId);
            updateShots(states.shots);
        });

        const updatePlayer = (players, socketId) => requestAnimationFrame(() => {
            worldCtx.beginPath();

            for (const i in players) {
                if (i === socketId) continue;
                const p = players[i];
                const x = p.x + middleTracker.x;
                const y = p.y + middleTracker.y;

                worldCtx.moveTo(x + playerRadius, y);
                worldCtx.arc(x, y, playerRadius, 0, pi2);
                worldCtx.fillText(p.name, x - 2 * playerRadius - 1.5 * p.name.length, y - 2 * playerRadius);
            }
            worldCtx.stroke();
            worldCtx.fillStyle = 'red';
            worldCtx.fill();
        });

        const updateShots = (shots) => requestAnimationFrame(() => {
            worldCtx.beginPath();
            for (const i in shots) {
                const shotPlayer = shots[i];
                shotPlayer.forEach(shot => {
                    const x = shot.position.x + middleTracker.x;
                    const y = shot.position.y + middleTracker.y;

                    worldCtx.moveTo(x + bulletRadius, y);
                    worldCtx.arc(x, y, bulletRadius, 0, pi2);
                });
            }
            worldCtx.fillStyle = 'black';
            worldCtx.fill();
        });

        const keysPressed = {}
        let mousePressed = false;
        let mousePos;
        document.body.addEventListener('keydown', (e) => {
            keysPressed[e.key] = true;
        });

        document.body.addEventListener('keyup', (e) => {
            delete keysPressed[e.key];
        });

        playerCanvas.addEventListener('mousedown', (e) => {
            mousePressed = true;
            mousePos = {
                x: Math.round((e.clientX / heightScale - middleTracker.x)),
                y: Math.round((e.clientY / heightScale - middleTracker.y))
            };
            console.log(mousePos);
        })

        socket.on('heartbeat', () => {
            if (mousePressed) {
                mousePressed = false;
                socket.emit('action1', mousePos);
            }
            for (const i in keysPressed) {
                if (i === 's') socket.emit('move down');
                else if (i === 'w') socket.emit('move up');
                else if (i === 'a') socket.emit('move left');
                else if (i === 'd') socket.emit('move right');
            }
        });
    </script>
</body>

</html>